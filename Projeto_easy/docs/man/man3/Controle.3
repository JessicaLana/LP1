.TH "Controle" 3 "Sat Jun 3 2017" "Controle" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Controle
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Controle\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBControle\fP ()"
.br
.ti -1c
.RI "\fBControle\fP (std::string ipAddrs_, unsigned long port, int n)"
.br
.ti -1c
.RI "\fB~Controle\fP ()"
.br
.ti -1c
.RI "void \fBload\fP (std::string path)"
.br
.ti -1c
.RI "void \fBconnect\fP ()"
.br
.ti -1c
.RI "void \fBgetSignal\fP ()"
.br
.ti -1c
.RI "void \fBcaptureLoop\fP ()"
.br
.ti -1c
.RI "void \fBrun\fP ()"
.br
.ti -1c
.RI "bool \fBrunning\fP ()"
.br
.ti -1c
.RI "cv::Point \fBgetCenter\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBSocket\fP \fBmSocket\fP"
.br
.ti -1c
.RI "std::thread \fBsocketThread\fP"
.br
.ti -1c
.RI "\fBDetector\fP \fBd\fP"
.br
.ti -1c
.RI "std::string \fBipAddrs\fP"
.br
.ti -1c
.RI "std::thread \fBdetectorThread\fP"
.br
.ti -1c
.RI "std::mutex \fBmutex\fP"
.br
.ti -1c
.RI "cv::Point \fBcenter\fP"
.br
.ti -1c
.RI "uint8_t \fBmSignal\fP"
.br
.ti -1c
.RI "int \fBvideoCaptureN\fP = 0"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class uses the state of a \fBDetector\fP to determine which signal shall be sent to the specified server\&. The processing loop runs concurrently with the connection loop 
.PP
Definition at line 23 of file Controle\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Controle::Controle ()\fC [inline]\fP"
Default constructor 
.PP
Definition at line 34 of file Controle\&.h\&.
.SS "Controle::Controle (std::string ipAddrs_, unsigned long port, int n)\fC [inline]\fP"
Constructor, simply initializes and ip address for server and the number of the capture device to be used 
.PP
Definition at line 35 of file Controle\&.h\&.
.SS "Controle::~Controle ()"
Default destructor 
.PP
Definition at line 52 of file Controle\&.cpp\&.
.PP
.nf
52                    {
53     //On destruction , joins running threads if they haven't exited yet\&.
54     if(detectorThread\&.joinable())
55         detectorThread\&.join();
56     if(socketThread\&.joinable())
57         socketThread\&.join();
58 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Controle::captureLoop ()"
Main capture loop, processes each frame with \fBDetector::detect\fP and updates center and mSignal 
.PP
Definition at line 6 of file Controle\&.cpp\&.
.PP
.nf
6                           {
7     cv::VideoCapture capture(0);
8     cv::Mat frame, image;
9     double scale = 1;
10     mutex\&.unlock();
11     if(!capture\&.isOpened())
12         std::cout << "Erro abrindo dispositivo de captura" << std::endl;
13     else{
14         while(1){
15             //Locks mutex during frame processing - which should take about 30ms\&.
16             mutex\&.lock();
17             capture >> frame;
18             if( frame\&.empty() )
19                 throw std::runtime_error("Frame vazio, falha ao capturar frame com dispositivo de captura selecionado");
20             cv::Mat frame1 = frame\&.clone();
21             //Updating center state
22             d\&.detect(frame1, scale);
23             center = d\&.getCenter();
24             getSignal();
25             //Press q || Q || ESC to exit\&.
26             char c = (char)cv::waitKey(10);
27             mutex\&.unlock();
28             if( c == 27 || c == 'q' || c == 'Q' ){
29                 std::exit(0);
30             }
31         } 
32     }
33 }
.fi
.SS "void Controle::connect ()"
Connect to server with ip ipAddrs 
.PP
Definition at line 34 of file Controle\&.cpp\&.
.PP
.nf
34                       {
35     mSocket\&.connectToServer();
36 }
.fi
.SS "cv::Point Controle::getCenter ()"
Returns the detected face's center as a cv::Point\&. This function is garanteed to wait for current frame processing loop to be done before returning detected face's center\&. 
.PP
Definition at line 59 of file Controle\&.cpp\&.
.PP
.nf
59                            {
60     //This function is garanteed to wait for current frame processing loop to be done before returning detected face's center\&.
61     std::lock_guard<std::mutex> guard{mutex};
62     return center;
63 }
.fi
.SS "void Controle::getSignal ()"
Determines which signal shall be sent to server and returns it, then updates mSignal 
.PP
Definition at line 2 of file Controle\&.cpp\&.
.PP
.nf
2                         {
3     if(center\&.x >= 300) mSignal = 'k';
4     else if(center\&.x <= 300) mSignal = 'o';
5 }
.fi
.SS "void Controle::load (std::string path)"
Loads a different classifier (LBP or Haar-like) 
.SS "void Controle::run ()"
Spawns detectorThread and socketThread with respective loops 
.PP
Definition at line 37 of file Controle\&.cpp\&.
.PP
.nf
37                   {
38     //Mutex unlocking is only done once thread is spawned and videoCapture device is set up and ready to go lest other threads reference Controle's state while it's still initializing
39     mutex\&.lock();
40     detectorThread = std::move(std::thread([=]{captureLoop();}));
41     std::cout << "Detector thread spawned and running";
42     socketThread = std::move(std::thread([=]{
43         connect();
44         while(1){
45             if(mSignal != 0)
46                 mSocket\&.sendData((char*)&mSignal, sizeof(uint8_t));
47         }
48     }));
49     std::cout << "Socket thread spawned and running" << std::endl;
50 }
.fi
.SS "bool Controle::running ()"
Returns 1 if detectorThread is currently running; returns 0 otherwhise 
.PP
Definition at line 64 of file Controle\&.cpp\&.
.PP
.nf
64                       {
65     //Returns 1 if detectorThread hasn't exited yet\&.
66     return detectorThread\&.joinable();
67 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "cv::Point Controle::center\fC [private]\fP"
Detected face's center 
.PP
Definition at line 30 of file Controle\&.h\&.
.SS "\fBDetector\fP Controle::d\fC [private]\fP"
\fBDetector\fP to be used 
.PP
Definition at line 26 of file Controle\&.h\&.
.SS "std::thread Controle::detectorThread\fC [private]\fP"
Frame processing thread 
.PP
Definition at line 28 of file Controle\&.h\&.
.SS "std::string Controle::ipAddrs\fC [private]\fP"
Server addres 
.PP
Definition at line 27 of file Controle\&.h\&.
.SS "uint8_t Controle::mSignal\fC [private]\fP"
Signal to be sent over network 
.PP
Definition at line 31 of file Controle\&.h\&.
.SS "\fBSocket\fP Controle::mSocket\fC [private]\fP"
Communication channell - a simple TCP \fBSocket\fP 
.PP
Definition at line 24 of file Controle\&.h\&.
.SS "std::mutex Controle::mutex\fC [private]\fP"
Mutex for syncrhonization 
.PP
Definition at line 29 of file Controle\&.h\&.
.SS "std::thread Controle::socketThread\fC [private]\fP"
This thread handles communication 
.PP
Definition at line 25 of file Controle\&.h\&.
.SS "int Controle::videoCaptureN = 0\fC [private]\fP"
Capture device to be used (defaults to installed webcam) 
.PP
Definition at line 32 of file Controle\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Controle from the source code\&.
